module Torid
  # Public: Represents a UUID generated by Torid
  #
  # Torid::UUID wraps a 128bit Integer value and can convert it back and forth
  # the following formats:
  #
  # - 36 byte hexadecimal string in the standard UUID format 8-4-4-4-12
  # - a 26 character string in crockford's base32
  # - 16 byte binary string
  # - 128bit Integer
  #
  # Since internally, Torid::UUID's represent a 128bit Integer, that includes
  # some sort of timestamp. Depending on the version of UUIDv6, UUIDv7, or UUIDv8 
  # there may be other accessors.
  #
  # Examples
  #
  #   uuid = Torid.uuid
  #   uuid.to_s    # => "0004fda3-8c73-5e0f-bae4-e9c86e3684a5"
  #   uuid.bytes   # => "\x00\x04\xFD\xA3\x8Cs^\x0F\xBA\xE4\xE9\xC8n6\x84\xA5"
  #   uuid.to_i    # => 1234567890
  #   uuid.as_ulid # => "01ARZ3NDEKTSV4RRFFQ69G5FAV"
  #
  class UUID

    # Regular expression that matches the 36 byte 8-4-4-4-12 format
    REGEX = %r{([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})}i

    # Public: Return if the given string matches the UUID regular expression
    #
    # str - The String to compare to REGEX
    #
    # Examples:
    #
    #   Torid::UUID.match( "0004fda3-8c73-5e0f-bae4-e9c86e3684a5" ) # => MatchData
    #
    # Returns MatchData or nil if there is no match
    def self.match( str )
      REGEX.match( str )
    end

    # Public: Create a Torid::UUID from an existing String.
    # The String can either be a 16 byte binary string, or a 36byte hexadecimal
    # UUID in the 8-4-4-4-12 format.
    #
    # str - The String from which to create the UUID.
    #
    # Examples
    #
    #   Torid::UUID.from( "0004fda3-8c73-5e0f-bae4-e9c86e3684a5" )                 # => Torid::UUID
    #   Torid::UUID.from( "\x00\x04\xFD\xA3\x8Cs^\x0F\xBA\xE4\xE9\xC8n6\x84\xA5" ) # => Torid::UUID
    #
    # Returns a Torid::UUID
    # Raises ArgumentError if the String is not convertable to a UUID.
    def self.from( str )
      return new(str) if str.is_a?(Integer)
      return from_bytes( str )  if str.bytesize == 16
      return from_uuid_string( str ) if UUID.match( str )
      return from_base32_string( str ) if Crockford::REGEX.match( str )
      raise ArgumentError, "UUID can only be loaded from a 16 byte binary string, 36 byte formatted UUID string, or a 26 character base32 string"
    end

    # Internal: Create a new UUID from an existing string in the 8-4-4-4-12 format
    #
    # str - The String from which to create the UUID.
    #
    # Copied from lexical_uuid
    #
    # Returns a Torid::UUID
    def self.from_uuid_string( str )
      hex   = str.split('-').join
      bytes = Array( hex ).pack("H32")
      from_bytes( bytes )
    end

    # Internal: Create a new UUID from an existing string in the Crockford Base32 format
    #
    # str - The String from which to create the UUID.
    #
    # Returns a Torid::UUID
    def self.from_base32_string( str )
      value = Crockford.decode( str )
      raise ArgumentError, "Crockfor base32 string must decode to a 128bit value" if value >= MAX.value
      new( value )
    end

    # Internal: Create a new UUID from an existing 16 byte String
    #
    # str - The binary string from which to create the UUID.
    #
    # Returns a Torid::UUID
    def self.from_bytes( bytes )
      a, b, c, d = bytes.unpack("NNNN")
      value = ( a << 96 ) | ( b << 64 ) | ( c << 32 ) | d
      new( value )
    end

    # Public: The timestamp value of the UUID
    attr_reader :timestamp

    # Public: The 128bit integer value of the UUID
    attr_reader :value
    alias :to_i :value

    # Internal: Create a new UUID.
    #
    # UUID's should only be created by calling one of the public methods that
    # generate id's. See `Torid.uuid` or `Torid::Generator.next`. This
    # constructor should not be called by users of this library.
    #
    # value - a 128bit Integer value
    #
    def initialize( value )
      @value = value
    end

    # Public: Return the Time value the internal microsecond timestamp
    # represents.
    #
    # Examples
    #
    #   uuid.time # => Time
    #
    # Returns a Time instance
    def time
      raise NotImplementedError, "This method must be implemented in a subclass"
    end

    # Public: Return the UUID as 16 bytes of raw data.
    #
    # Copied from lexical_uuid
    #
    # Examples
    #
    #   uuid.bytes # => "\x00\x04\xFD\xA3\x8Cs^\x0F\xBA\xE4\xE9\xC8n6\x84\xA5"
    #
    # Returns a binary String
    def bytes
      @bytes ||= (
        _bytes = @value.digits(256).reverse
        _bytes.unshift(0) until _bytes.length == 16
        _bytes.pack("C*")
      )

    end

    # Public: Return the hexadecimal UUID string representation. This is the
    # standard 8-4-4-4-12 UUID string representation.
    #
    # Copied from simple_uuid via lexical_uuid.
    #
    # Examples
    #
    #   uuid.to_s  # => "0004fda3-8c73-5e0f-bae4-e9c86e3684a5"
    #
    # Returns a String
    def to_s
      debugger
      elements     = bytes.unpack("NnnCCa6")
      twelve       = elements[-1].unpack('C*')
      elements[-1] = '%02x%02x%02x%02x%02x%02x' % twelve
      "%08x-%04x-%04x-%02x%02x-%s" % elements
    end

    # Public: Compare the equality of UUID's
    #
    # Examples
    #
    #   uuid == other_uuid
    #
    # Returns true or false
    def ==(other)
      other.is_a?(::Torid::UUID) &&
        other.value == self.value
    end
    alias :eql? :==

    # Public: Generate the hash of the UUID for ruby hash equality
    #
    # This allows two UUID objects that have the value to
    # be considered the same object for keys in Hash.
    #
    # Examples
    #   one   = Torid.uuid
    #   other = Torid::UUID.from( one.bytes )
    #   h     = { one => "a value" }
    #   h.has_key?( other )  # => true
    def hash
      [value, ::Torid::UUID].hash
    end

    MIN = Torid::UUID.new(0)
    MAX = Torid::UUID.new(0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF)
  end
end
