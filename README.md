# Torid

[![Build Status](https://copiousfreetime.semaphoreci.com/badges/torid/branches/main.svg)](https://copiousfreetime.semaphoreci.com/projects/torid)

* [Homepage](https://github.com/copiousfreetime/torid/)
* [Github Project](https://github.com/copiousfreetime/torid)

## DESCRIPTION

A library to generate UUID's that are temporally ordered when sorted
lexigraphically. Torid implements UUIDv6, UUIDv7, and UUIDv8.

## DETAILS

Torid exists to solve the problem of generating UUIDs that when ordered
lexically, they are also ordered temporally. I needed a way to generate ids for
events that are entering a system with the following criteria:

1. Fast ID generation
2. No central coordinating server/system
3. No local storage
4. Library code, that is multiple apps on the same machine can use the same code
   and they will not generate duplicate ids
5. Eventually stored in a UUID field in a database. So 128bit ids are totally
   fine.

Torid generates these id's in multiple different algorithms, you may choose
which one you want.

## EXAMPLES

#### Using the defaults

```ruby
require 'torid'

# Generate a UUIDv7 that defaults to UUID format
uuid = Torid.uuid
uuid.to_s         # => "0004fda4-318e-f380-5a45-5321cd065b02"
uuid.bytes        # => "\x00\x04\xFD\xA41\x8E\xF3\x80ZES!\xCD\x06[\x02"
uuid.as_ulid      # =>
uuid.to_i         # =>

# Generator a UUIDv7 that defaults to ULID display format
ulid = Torid.ulid
ulid.to_s         # =>
ulid.bytes        # => "\x00\x04\xFD\xA41\x8E\xF3\x80ZES!\xCD\x06[\x02"
ulid.as_uuid      # => "0004fda4-318e-f380-5a45-5321cd065b02"
ulid.to_i         # => 
```

#### Using your own instance of a Generator

```ruby
require 'torid'

generator = Torid::Generator.new
uuid      = generator.next

uuid.to_s        # => "0004fda4-3f42-3d01-4731-5a4aa8ddd6c3"
uuid.bytes       # => "\x00\x04\xFD\xA4?B=\x01G1ZJ\xA8\xDD\xD6\xC3"
uuid.as_ulid     # =>
```

#### Configure the Generator

```ruby

# Default uuidv7 generator
uuidv7_generator = Torid::Generator.new

# Default uuidv7 generator that defaults to ulid string format
ulid_generator = Torid::Generator.new(format: :ulid)

# uuidv8 generator that defaults to ulid string format
ulid_v8_generator = Torid::Generator.new(format: :ulid, algorithm: :v8)

```

## UUID Representation

All the UUID values generated by Torid may be displayed in any of the following
formats:

* the standard 8-4-4-4-12 hexadecimal UUID format
* a base 32 crockford encoded string, also known as [ULID format](https://github.com/ulid/spec)
* an array of 16 bytes
* a 128 bit integer

## Algorithms

Torid implments all the UUID formats detailed in [New UUID Formats
RFC](https://datatracker.ietf.org/doc/html/draft-peabody-dispatch-new-uuid-format).

The default algorithm for Torid is the UUIDv7 algorithm.

Torid's original custom algorithm is now the UUIDv8 implementation.

### UUIDv6

This is a field-compatible version of UUIDv1, with the time bits reordered so
they sort lexically in time order. You probably don't want this unless you are
migrating from a UUIDv1 system.

The UUIDv6 uses a 60 bit timestamp of the number of 100 nanosecond intervals
(0.1 microseconds) from 00:00:00.00 15 Oct 1585.

* 48 most significant bits of a 60 bit timestamp
* 4 bits containing the UUIDv6 version (0110)
* 12 least significant bits of the 60 bit timestamp
* 2 bits (10) for the UUID variant
* 14 bit clock sequence value
* 48 bit node_id

### UUIDv7

I am also calling this the [ULID implementation](https://github.com/ulid/spec)
and is aliased as such.

* 48 bit timestamp of the number of milliseconds from UNIX Epoch
* 4 bits containing the UUIDv7 version (0111)
* 12 bit of pseudo random data
* 2 bit variant (10)
* 62 bits of pseudo random data

### UUIDv8

Torid had an original temporally ordered uuid generation algorithm that existed
before the new UUIDv7/8/9 standard was proposed. That algorithm is now slightly
altered and is the UUIDv8 implementation.

The IDs that Torid generated in version 1.x were 128bit IDs made up of 2, 64bit
parts.

* 64bit microseconds since the UNIX epoch
* 64bit hash of the system hostname, process id and a random value.

In version 2.x the custom algorithm is the same, but the bit fields are now:

* 48 most significant bits of a 64bit microseconds since the UNIX epoch
* 4 bits containing the UUIDv8 version (1000)
* 12 middle significant bits of the 64bit microseconds since the UNIX epoch
* 2 bit variant (10)
* 4 least significant bits of the 64bit microseconds since the UNIX epoch
* 58 bits of the system hostname, process id and a random value.

## CREDITS / RESOURCES

The vast majority of the credit and research stems from:

* [jondot's](https://github.com/jondot) blog post on [Fast ID Generation](http://blog.paracode.com/2012/04/16/fast-id-generation-part-1/) served to solidify my thoughts on the criteria I needed in an ID generation system. 
* This let me to [Boundary's Flake](http://boundary.com/blog/2012/01/12/flake-a-decentralized-k-ordered-unique-id-generator-in-erlang/)
* [James Golick's](https://github.com/jamesgolick) [lexical_uuid](https://github.com/jamesgolick/lexical_uuid), which if I had found a day earlier, I might be using instead of creating this.
* [ulid specification](https://github.com/ulid/spec)
* [draft-peabody-dispatch-new-uuid-format-04](https://datatracker.ietf.org/doc/html/draft-peabody-dispatch-new-uuid-format)

You could consider Torid to be a reimplementation of [lexical_uuid](https://github.com/jamesgolick/lexical_uuid). It definately steals some code from it and [simple_uuid](https://github.com/cassandra-rb/simple_uuid)
and an implementation of [ulid](https://github.com/ulid/spec).

Blog posts around ID generation:

* [Wikipedia UUID](http://en.wikipedia.org/wiki/Universally_unique_identifier)
* [RFC 4122](http://tools.ietf.org/html/rfc4122)
* [Fast ID Generation Part I](http://blog.paracode.com/2012/04/16/fast-id-generation-part-1/)
* [Boundary's Flake Project](http://boundary.com/blog/2012/01/12/flake-a-decentralized-k-ordered-unique-id-generator-in-erlang/)
* [Flickr's Ticket Server](http://code.flickr.net/2010/02/08/ticket-servers-distributed-unique-primary-keys-on-the-cheap/)
* [Twitter Snowflake](https://blog.twitter.com/2010/announcing-snowflake)
* [Sharding & ID's at Instagram](http://instagram-engineering.tumblr.com/post/10853187575/sharding-ids-at-instagram)

Libraries implementing similar approaches:

* [simple_uuid](https://github.com/cassandra-rb/simple_uuid)
* [uuid](https://github.com/assaf/uuid)
* [flake](http://github.com/boundary/flake)
* [BSON Object ID](https://github.com/mongodb/bson-ruby/blob/master/lib/bson/object_id.rb) and in [C](https://github.com/mongodb/bson-ruby/blob/master/ext/bson/native.c)
* [ffi-uuid](https://github.com/mmullis/ffi-uuid)
* [lexical_uuid](https://github.com/jamesgolick/lexical_uuid)

## ISC LICENSE

http://opensource.org/licenses/isc-license.txt

Copyright (c) 2014 Jeremy Hinegardner

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted, provided that the above
copyright notice and this permission notice appear in all copies.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.

